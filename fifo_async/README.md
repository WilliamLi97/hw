# Asynchronous FIFO
The asynchronous FIFO is used as a buffer in between clock domain crossings (CDCs), and as such, is a very important hardware block. For this reason, basic familiarity with CDCs is assumed here; please review the `cdc` directory if needed. This implementation is largely based on a paper by Clifford E. Cummings at Sunburst Design, available [here](http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf). The paper details the necessary components, explains their purpose, and is a great read for anyone interested in asynchronous FIFO design. In this readme, I will provide a summary of the key aspects of an asynchronous FIFO.

The differences between the asynchronous FIFO and the synchronous FIFO all arise from the fact that we need to operate between two different clock domains. Thus, all the additional components are used to address the CDC. Familiarity with the synchronous FIFO will be assumed from this point; please review the `fifo` directory if needed. 

We can start by looking at what components of the synchronous FIFO would be sensitive to the clock domain crossing. The memory is the same between the two clock domains. The read enable comes from, and is used only in the read domain. Likewise for the write enable. The input data only needs to be clocked using the write clock, and the output data only needs to be clocked using the read clock. The only thing remaining is the full and empty signals. In the synchronous FIFO, both the full and empty signals are generated using the read and write pointers, requiring information from across the CDC. More specifically, the full signal will require the write pointer to cross the CDC, and the empty signal will require the read pointer to cross the CDC.

Now that we have identified that the issue is with moving the read and write pointers across the CDC, we can consider how we want to solve this problem. The simplest solution would be to use flop chaining to move the pointers across the CDC. However, flop chaining by itself is not sufficient because when moving a signal consisting of multiple bits across the CDC, we cannot guarantee that all the bits will arrive in the destination domain on the same clock edge, and chances are the read and write pointers are going to be larger than 1 bit. So flop chaining is a no-go? Not quite. Fortunately, we can exploit the fact that the read and write pointers only ever increment upwards by 1 at a time. If we use gray code, this translates to only one bit flip per update while the rest are held steady. In other words, using gray code will allow us to guarantee that only 1 bit of data is being sent through the CDC at a time, and thus we can use flop chaining. The alternative, if we wanted to stick with binary counters, is to employ handshake synchronization to move the pointers across the CDC. This is generally undesireable as it would slow down the operation of the FIFO significantly.

Now, there is just one more thing: now that both sides of the CDC can read the gray-coded pointer from the other side, how do we determine that the FIFO is empty or full? For the empty signal, we want to check if the two pointers are equal. Fortunately, each entry in a gray code is unique, so if the gray code representation of both pointers are equal, we know the FIFO is full. The full signal is a bit tricker. In the synchronous FIFO, we used an extra bit to distinguish between an empty and full FIFO when all bits other than the MSB are equal. Ideally, we would be able to do the same. However, if we look combinations of 3-bit gray coded pointers that should result in the FIFO signalling that it is full:

$000 \land 110$  
$001 \land 111$  
$011 \land 101$  
$010 \land 100$  

There is actually a pattern: the first two bits are different from each other, the the last bit is the same. If we expand this to four or more bit gray-coded pointers, we would find that the first two bits must be different from the first two bits of the other pointer, and the rest of the bits must be the same. It is unlikely a FIFO will be small enough to only require 2 pointer bits each (1 bit would not be possible for this implementation because the MSB is used to determine if the pointer has wrapped around), but in that case, we would need to check that the first two bits of one pointer is different from the first two bits of the other.

One last thing I want to mention is that that this implementation will create a pessimistic asynchronous FIFO. It is said to be pessimistic because the source domain immediately knows when the FIFO is full, and the destination domain immediately knows when the FIFO is empty, but there is some delay before they find out the FIFO is no longer full, or no longer empty.

## Implementation
### Asynchronous FIFO
An implementation and testbench for an asynchronous FIFO is included. It can be simulated to generate a `.vcd` file using the included makefile:  
`make compile COMPILE_MODULE=fifo_async_tb`
